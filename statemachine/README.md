# Вебинар 32. StateMachine

1. Узкие места официально рекомендуемой архитектуры и [Jetpack Navigation](https://developer.android.com/guide/navigation/use-graph/conditional)
2. Navigation Inversion - смена традиционного подхода к навигации и архитектуре в приложении
3. StateMachine - вариант простой и доступной UDF-архитектуры

## Вопросы для самопроверки:

1. В чем трудности навигации Jetpack Compose изнутри `ViewModel`?
   [] ViewModel не может взаимодействовать с Composable функциями.
   [] ViewModel не имеет прямого доступа к `NavController` или `Context`, что затрудняет прямую навигацию. Она должна делегировать события навигации 
      слою UI (Composable) через состояния или одноразовые события.
   [] Jetpack Compose не поддерживает навигацию из ViewModel.
2. В чем проблема поддерживаемости монолитных ViewModel, обслуживающих несколько экранов?
   [] Монолитные ViewModel потребляют слишком много оперативной памяти.
   [] Монолитные ViewModel становятся слишком большими, сложными для понимания, тестирования и модификации, так как они содержат логику для множества экранов, 
      что приводит к сильной связанности и затрудняет повторное использование кода.
   [] Монолитные ViewModel автоматически блокируют основной поток UI.
3. В чем основные черты архитектуры MVI для внешнего клиента `ViewModel`? Как мы передаем действия пользователей и получаем обновления экрана?
   [] В MVI ViewModel напрямую манипулирует UI-элементами.
   [] MVI (Model-View-Intent) характеризуется однонаправленным потоком данных: пользователи отправляют действия (Intent) во ViewModel, ViewModel обрабатывает 
      их и генерирует новое состояние (State), которое затем отображается во View. View только отображает состояние и отправляет Intent.
   [] В MVI View напрямую изменяет модель данных.
4. В чем заключается принцип паттерна StateMachine, и как он относится к архитектуре MVI?
   [] Паттерн StateMachine используется для автоматической генерации UI-кода.
   [] Паттерн StateMachine описывает систему, которая может находиться в одном из конечного числа состояний и переходить между ними в ответ на события, 
      при этом каждый переход определен. В MVI StateMachine используется внутри ViewModel для управления сложной бизнес-логикой и генерации нового состояния 
      на основе входящих Intent и текущего состояния, обеспечивая предсказуемость.
   [] Паттерн StateMachine предназначен для сохранения состояния приложения в базе данных.
