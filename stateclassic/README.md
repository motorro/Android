# Вебинар 14. Архитекрурные компоненты Android (классический подход)

1. Проблема повторного использования кода в Activity и решение - Livecycle Observer
2. Тестируемые компоненты Livecycle Observer
3. Проблема концентрации кода в Activity и решение - ViewModel, LiveData, MVVM
4. Тестируемые компоненты ViewModel, LiveData
5. Сохранение состояния Activity и решение - ViewModel, SavedStateHandle

## Вопросы для самопроверки:

1. Что такое Livecycle Observer?
   [] Livecycle Observer - это интерфейс, который позволяет делегировать часть обработки событий жизненного цикла компонентов с Lifecycle (например, Activity)
      выделенным дополнительным компонентам.
   [] Livecycle Observer - это компонент, который позволяет отслеживать изменения данных в базе данных.
   [] Livecycle Observer - это класс, который управляет сетевыми запросами.
2. В чем преимущество использования Lifecycle Observer?
   [] Lifecycle Observer позволяет выполнить код в Activity после завершения всех фоновых задач.
   [] Lifecycle Observer помогает отделить логику, зависящую от жизненного цикла, от Activity/Fragment, что делает код более чистым, модульным и легким 
      для тестирования. Он позволяет безопасно выполнять действия в ответ на изменения состояния жизненного цикла.
   [] Lifecycle Observer обеспечивает автоматическую синхронизацию данных между Activity и ViewModel.
3. Какие проблемы возникают при концентрации кода в Activity?
   [] Проблемы с производительностью приложения из-за избыточного количества Activity.
   [] Увеличение размера APK файла и сложности развертывания приложения.
   [] `God Object` (раздутая Activity), сложности с тестированием (поскольку логика тесно связана с Android SDK), проблемы с сохранением состояния при изменении 
      конфигурации (например, поворот экрана), и трудности с повторным использованием кода.
4. Что такое ViewModel и какие проблемы она решает?
   [] ViewModel - это компонент UI, отвечающий за отображение данных пользователю.
   [] ViewModel - это класс, предназначенный для хранения и управления данными пользовательского интерфейса таким образом, чтобы данные переживали изменения 
      конфигурации (например, поворот экрана). Она решает проблему потери данных при пересоздании Activity/Fragment и упрощает тестирование логики UI, 
      отделяя ее от View.
   [] ViewModel - это база данных для хранения локальных данных приложения.
5. Что такое LiveData и каким образом View получает данные из ViewModel?
   [] LiveData - это механизм для выполнения фоновых операций в Android.
   [] LiveData - это наблюдаемый класс-хранитель данных, который учитывает жизненный цикл. View (Activity/Fragment) подписывается на LiveData в ViewModel 
      и получает обновления данных только тогда, когда компонент находится в активном состоянии жизненного цикла, что предотвращает утечки памяти.
   [] LiveData - это способ взаимодействия между Activity и Service.
6. Как написать тестируемую логику в ViewModel?
   [] Для тестирования ViewModel необходимо запускать приложение на эмуляторе и вручную проверять все сценарии.
   [] Тестируемая логика в ViewModel пишется с использованием передаваемых извне зависимостей, которые можно имитировать во время модульного тестирования. 
      ViewModel не должна иметь прямых зависимостей от Android SDK View или Context, что позволяет тестировать ее как обычный Java/Kotlin класс.
   [] Тестируемая логика в ViewModel пишется с использованием специальных аннотаций, которые автоматически генерируют тестовые кейсы.
7. Что такое SavedStateHandle и как она используется в ViewModel?
   [] SavedStateHandle - это компонент для работы с сетевыми запросами.
   [] SavedStateHandle - это карта ключ-значение, которая позволяет ViewModel сохранять и восстанавливать данные, переживая процесс уничтожения процесса Activity 
      системой (например, при нехватке памяти). Она используется в конструкторе ViewModel для получения доступа к сохраненному состоянию, похожему на 
      `onSaveInstanceState()` Activity, но привязанному к ViewModel.
   [] SavedStateHandle - это механизм для работы с общими настройками приложения.