# Вебинар 1. Уведомления

1. Основы работы с уведомлениями: разрешения и каналы.
2. Создание и управление локальными уведомлениями.
3. Интерактивные уведомления: действия, кнопки и ответы.
4. Введение в Push-сообщения: теория и архитектура FCM.
5. Практическая реализация Push-уведомлений с Firebase Cloud Messaging.

### Вопросы для самопроверки

1.  Какие два обязательных шага необходимо предпринять в коде, чтобы уведомление успешно отобразилось на современном устройстве Android (API 33+)? Почему каждый
    из этих шагов является критически важным?
    [] Достаточно просто вызвать `NotificationManager.notify()` с любым уведомлением; система сама определит, как его показать.
    [] Получение разрешения `POST_NOTIFICATIONS` от пользователя и создание канала уведомлений (`NotificationChannel`). Разрешение критически важно, так как 
       без него система не покажет уведомление. Канал критически важен, так как он определяет поведение и важность уведомления, а уведомления без канала 
       при версии Android 26+ не отображаются.
    [] Необходимо только добавить уведомление в манифест приложения и отправить его с помощью `Intent`.
2.  В чем заключается основная роль `PendingIntent` при создании интерактивных уведомлений? Почему для добавления действия (например, открытия экрана) нельзя 
    передать системе обычный `Intent` напрямую?
    [] `PendingIntent` используется для шифрования данных, передаваемых с уведомлением.
    [] `PendingIntent` является оберткой для `Intent`, которая предоставляет системе Android право выполнить `Intent` от имени вашего приложения позже, 
       даже если ваше приложение не запущено. Нельзя передать обычный `Intent` напрямую, потому что система должна иметь возможность выполнить его *после того*,
       как ваше приложение, возможно, будет уничтожено или находится в неактивном состоянии. `PendingIntent` действует как "токен", дающий системе это разрешение.
    [] `PendingIntent` нужен для того, чтобы уведомление всегда открывало главный экран приложения.
3.  Опишите сценарий, в котором ваше приложение получит push-сообщение, но **не** покажет видимое для пользователя уведомление. Как называется тип полезной 
    нагрузки (payload) в FCM, который позволяет это реализовать, и какова его основная цель?
    [] Это невозможно, любое push-сообщение FCM всегда приводит к видимому уведомлению.
    [] Сценарий: приложение получает push-сообщение, которое содержит только `data` полезную нагрузку (data-message), но не `notification` полезную нагрузку. 
       В этом случае FCM доставляет сообщение напрямую в метод `onMessageReceived()` вашего `FirebaseMessagingService`, и приложение может обработать данные без 
       показа видимого уведомления. Основная цель `data` полезной нагрузки - отправка данных приложению для фоновой обработки или внутренней логики.
    [] Приложение получит push-сообщение с `notification` полезной нагрузкой, но пользователь просто проигнорирует его.
4.  Ваше приложение находится в фоновом режиме (background). С сервера отправляется push-сообщение, содержащее **одновременно** и `notification`, и `data` 
    полезные нагрузки. Будет ли в этом случае вызван метод `onMessageReceived()` в вашем `FirebaseMessagingService` и какой компонент в первую очередь 
    обработает это сообщение?
    [] Да, `onMessageReceived()` будет вызван, и он обработает обе части сообщения.
    [] Нет, сообщение будет полностью проигнорировано, так как оно содержит обе полезные нагрузки.
    [] Если приложение находится в фоновом режиме, и push-сообщение содержит **обе** полезные нагрузки (`notification` и `data`), то `onMessageReceived()` в 
       `FirebaseMessagingService` **не будет вызван** для обработки `notification` части. Вместо этого `notification` часть будет обработана самой системой 
       Android, которая отобразит уведомление в системном трее. `data` полезная нагрузка будет доступна через `Intent`, который запускается при нажатии 
       пользователем на уведомление.
5.  Каково назначение регистрационного токена FCM и почему критически важно реализовывать метод `onNewToken()`? Что со временем произойдет, если вы получите 
    и отправите токен на сервер только один раз при первой установке приложения?
    [] Регистрационный токен FCM используется для аутентификации пользователя в приложении. `onNewToken()` нужен для обновления пароля пользователя.
    [] Регистрационный токен FCM - это уникальный идентификатор для конкретного экземпляра приложения на конкретном устройстве, используемый для отправки 
       push-сообщений именно этому экземпляру. Критически важно реализовывать `onNewToken()`, потому что токен может меняться (например, при переустановке 
       приложения, сбросе данных). Если отправлять токен на сервер только один раз, со временем сервер будет пытаться отправлять сообщения на устаревший токен, 
       и уведомления не будут доходить до пользователя, так как устройство больше не будет ассоциироваться с этим токеном.
    [] Регистрационный токен FCM нужен только для аналитики. Если его не обновлять, это не повлияет на доставку уведомлений.

