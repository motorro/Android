# Вебинар 3. Современный технологический стек

1. Современный UI: Jetpack Compose
2. Состояние приложения и логика
3. Обмен данными по сети
4. Управление зависимостями - DI
5. Локальное хранение данных и offline-first
6. Фоновые задачи и планировщик

## Тестовый сервер:

Для запуска сервера воспользуйтесь задачей `run` соответствующего модуля из панели Gradle или введите команду:
```shell
./gradlew :tasks:server:run
```
Логин пользователя: `username`
Пароль пользователя: `password`

Приложение расчитано на запуск сервера на локальном компьютере и приложения на эмуляторе.
Если вы хотите установить приложение на телефон, измените адрес сервера в [этом файле](src/main/kotlin/ru/merionet/tasks/core/Config.kt).

## Вопросы для самопроверки:

1. Какой основной принцип лежит в основе Jetpack Compose?
   [] Декларативный подход к построению пользовательского интерфейса, где вы описываете, как UI должен выглядеть для данного состояния, а Compose сам управляет 
      изменениями.
   [] Императивный подход, требующий явного управления элементами UI и их атрибутами.
   [] XML-разметка для описания UI, а затем императивное изменение ее в коде.
2. Чего мы ждем от архитектуры приложения, и зачем она нам нужна?
   [] От архитектуры приложения мы ожидаем масштабируемости, тестируемости, поддерживаемости и разделения ответственности. Она нужна для организации кода таким 
      образом, чтобы он был понятным, легко изменяемым и устойчивым к ошибкам.
   [] Архитектура приложения нужна только для того, чтобы оно выглядело красиво.
   [] Архитектура приложения никак не влияет на его производительность.
3. Что облегчает обмен данными с сервером?
   [] Использование библиотек для работы с сетью (например, Ktor, Retrofit), которые абстрагируют низкоуровневые детали HTTP-запросов и ответов, предоставляют 
      удобные API для сериализации/десериализации данных и обработки ошибок.
   [] Ручная реализация всех сетевых запросов с использованием стандартных Java-классов.
   [] Отсутствие обмена данными с сервером вообще, так как это всегда сложно.
4. Какие виды локального хранения вы знаете?
   [] Локальное хранение данных может быть реализовано с помощью: Room Persistence Library (для структурированных данных в SQLite-базе), файлов (для больших 
      объемов неструктурированных данных) и DataStore (для асинхронного и типобезопасного хранения данных).
   [] Все данные должны храниться только на удаленном сервере.
   [] Локальное хранение данных не имеет никакого смысла в современных приложениях.
5. Какие преимущества дает использование планировщика?
   [] Использование планировщика (WorkManager) позволяет эффективно управлять фоновыми задачами, гарантируя их выполнение даже при закрытии приложения или 
      перезагрузке устройства, а также соблюдая системные ограничения и оптимизируя потребление ресурсов.
   [] Планировщик нужен только для выполнения задач, которые должны выполняться строго по расписанию, например, будильник.
   [] Планировщик значительно усложняет код и не дает никаких реальных преимуществ.
 
 
