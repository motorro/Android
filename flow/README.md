# Вебинар 19. Kotlin Flow

Вебинар состоит из двух модулей:
1. `flow` - основной модуль приложения 
2. `experiments` - модуль для экспериментов с Flow

## Содержание

1. Реактивное программирование и Flow
2. Получение данных и контекст
3. Преобразования и объединения
4. SharedFlow и StateFlow
5. Обработка ошибок

## Вопросы для самопроверки:

1. Что такое реактивное программирование?
   [] Реактивное программирование - это парадигма программирования, ориентированная на потоки данных и распространение изменений. Оно позволяет работать 
      с асинхронными потоками данных, реагируя на изменения и события.
   [] Реактивное программирование - это способ написания синхронного кода для повышения производительности.
   [] Реактивное программирование - это только для работы с UI-элементами.
2. Как мы создаем реактивные потоки в Kotlin?
   [] Реактивные потоки в Kotlin создаются только с помощью `LiveData`.
   [] Реактивные потоки в Kotlin чаще всего создаются с помощью `Flow` из библиотеки Kotlin Coroutines. Можно использовать билдеры `flow`, `flowOf`, `asFlow` 
      для создания холодных потоков, а также `MutableSharedFlow` и `MutableStateFlow` для создания горячих потоков.
   [] Реактивные потоки в Kotlin создаются путем реализации интерфейса `Observable`.
3. Как подписаться на поток и получить данные?
   [] Для подписки на поток нужно вызвать метод `subscribe()` на Flow.
   [] Подписка на поток (коллекция) осуществляется с помощью терминальных операторов, таких как `collect()`. Этот оператор является suspend-функцией и должен 
      быть вызван в корутине.
   [] Подписка на поток происходит автоматически при объявлении Flow.
4. Когда поток начинает выполняться?
   [] Поток начинает выполняться сразу после его объявления.
   [] Холодные потоки (`Flow`) начинают выполняться только тогда, когда на них подписывается коллектор (`collect()`). Горячие потоки (`SharedFlow`, `StateFlow`) 
      начинают выполняться при первом подписчике или сразу, в зависимости от конфигурации.
   [] Поток начинает выполняться только после вызова метода `start()`.
5. Какие операторы преобразования потоков вы знаете?
   [] Только операторы для фильтрации данных, такие как `filter()`.
   [] Операторы преобразования включают `map()`, `filter()`, `onEach()`, `debounce()`, `sample()`, `flatMapConcat()`, `flatMapMerge()`, `zip()`, `combine()`.
   [] Операторы преобразования потоков используются для изменения типа данных потока на другой, не связанный с исходным.
6. Чем отличается SharedFlow от StateFlow?
   [] SharedFlow и StateFlow - это одно и то же, просто разные названия.
   [] SharedFlow - это горячий поток, который отправляет элементы всем своим подписчикам и не имеет начального значения. StateFlow - это горячий поток, который 
      всегда имеет начальное значение, отправляет только уникальные (distinct) обновления состояния своим подписчикам и всегда сохраняет последнее отправленное 
      значение.
   [] SharedFlow может быть только один на приложение, а StateFlow может быть несколько.
7. Как обрабатывать ошибки в потоках?
   [] Ошибки в потоках всегда приводят к краху приложения и не могут быть обработаны.
   [] Ошибки в потоках обрабатываются с помощью оператора `catch()` для перехвата исключений, а также с помощью `try-catch` блоков внутри корутин, подписанных 
      на Flow.
   [] Ошибки в потоках обрабатываются только в главном потоке UI.