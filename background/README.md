# Вебинар 35. Фоновая работа

1. Фоновая работа в Android. Общие понятия.
2. Started и Bound сервисы.
3. Периодические задачи в WorkManager
4. Составные задачи в WorkManager

## Вопросы для самопроверки:

1. В чем принципиальное различие между `Service` и `Thread` с точки зрения управления жизненным циклом и потоком выполнения? 
   [] `Service` является компонентом Android, работающим в основном потоке приложения по умолчанию и предназначенным для выполнения длительных 
   операций без взаимодействия с UI. Его жизненный цикл управляется системой Android. `Thread` — это низкоуровневая конструкция для 
   выполнения кода в отдельном потоке, не связанная напрямую с жизненным циклом компонентов Android и не имеющая собственного UI.
   [] `Service` всегда выполняется в отдельном фоновом потоке, созданном системой, что освобождает основной поток приложения. `Thread` же 
   всегда запускается в основном потоке и блокирует UI, пока не завершится.
   [] `Service` и `Thread` по своей сути одно и то же, просто `Service` имеет удобный API для управления фоновой работой, но оба они 
   управляются JVM, а не системой Android.
2. Для какой задачи вы выберете `Foreground Service`, и какое основное требование система Android предъявляет к его работе?
   [] `Foreground Service` используется для любых задач, требующих повышенного приоритета, даже если они кратковременны. Система требует,
   чтобы он показывал уведомление, которое пользователь может смахнуть в любой момент.
   [] `Foreground Service` выбирается для задач, которые должны быть заметны пользователю и продолжаться, даже если приложение не активно 
   (например, воспроизведение музыки, отслеживание местоположения). Основное требование — наличие постоянного уведомления, видимого 
   пользователю, сообщающего о работе сервиса.
   [] `Foreground Service` предназначен для выполнения длительных фоновых операций, которые не требуют прямого взаимодействия с пользователем 
   и не должны отображать уведомление, чтобы не отвлекать его.
3. Какую роль выполняет метод `onBind()` в компоненте `Service` и в каком случае он вызывается?
   [] `onBind()` вызывается сразу после `onCreate()` для всех типов сервисов, чтобы подготовить сервис к приему команд, даже если к нему
   никто не привязывается.
   [] Метод `onBind()` вызывается только в `Started Service` для инициализации фоновой работы, возвращая `null`, так как привязка в таком 
   сервисе невозможна.
   [] Метод `onBind()` вызывается, когда другой компонент приложения (например, `Activity`) пытается привязаться к `Service`, чтобы
   взаимодействовать с ним. Он возвращает `IBinder` объект, который является интерфейсом для взаимодействия клиента с сервисом.
4. В какой ситуации для выполнения фоновой задачи вы предпочтете `WorkManager`, а не `Foreground Service`? Приведите пример для каждого. 
   [] `WorkManager` следует использовать, когда требуется немедленное выполнение задачи и отображение прогресса в UI, например, для 
   загрузки большого файла с индикатором. `Foreground Service` подходит для очень коротких операций без взаимодействия с пользователем.
   [] `WorkManager` предпочтителен для отложенных, гарантированных и фоновых задач, которые не требуют немедленного выполнения или не
   должны быть постоянно видимы пользователю (например, синхронизация данных раз в день, загрузка изображений в фоновом режиме).
   `Foreground Service` — для задач, требующих немедленного и непрерывного выполнения, видимых пользователю
   (например, стриминг аудио).
   [] `WorkManager` идеален для любых фоновых задач, которые должны быть выполнены немедленно и с максимальным приоритетом. 
   `Foreground Service` применяется только для задач, которые могут быть отложены и не критичны для пользователя, но все же требуют 
   фоновой работы.
5. Как с помощью `WorkManager` организовать последовательное выполнение задач, где сначала загружаются несколько файлов, а затем отправляется 
   итоговый отчет с результатами их загрузки? 
   [] `WorkManager` не поддерживает прямое последовательное выполнение нескольких независимых задач. Вместо этого нужно запускать все 
   задачи по загрузке параллельно, а затем вручную инициировать отправку отчета после их завершения.
   [] Для последовательного выполнения задач в `WorkManager` можно использовать `WorkManager.beginWith()`, затем `then()` для добавления 
   последующих задач. Например: `WorkManager.getInstance(context).beginWith(uploadFileAWorkRequest).then(uploadFileBWorkRequest).
   then(sendReportWorkRequest).enqueue()`.
   [] Для такой задачи достаточно создать один `Worker`, который внутри себя будет по очереди вызывать методы для загрузки файлов, а затем 
   метод для отправки отчета, без использования цепочек `WorkManager`.