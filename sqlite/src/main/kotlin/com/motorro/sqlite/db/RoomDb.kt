package com.motorro.sqlite.db

import android.content.Context
import android.net.Uri
import androidx.room.AutoMigration
import androidx.room.Database
import androidx.room.Room
import androidx.room.RoomDatabase
import androidx.room.TypeConverters
import androidx.room.migration.Migration
import androidx.sqlite.db.SupportSQLiteDatabase
import androidx.sqlite.db.transaction
import com.motorro.sqlite.data.Converters
import com.motorro.sqlite.data.Image
import com.motorro.sqlite.data.ListImage
import com.motorro.sqlite.data.ListTag
import com.motorro.sqlite.data.PhotoFilter
import com.motorro.sqlite.data.Tag
import kotlinx.coroutines.flow.Flow

/**
 * Wrapper for Room database
 * Uses Room DAO to access data
 * @param db Room database
 */
class PhotoDbImpl private constructor(private val db: RoomDb): PhotoDb {
    override fun getList(filter: PhotoFilter): Flow<List<ListImage>> = when {
        filter.name.isNullOrBlank() && filter.tags.isEmpty() -> db.imageDao().getList()
        filter.name.isNullOrBlank() -> db.imageDao().getList(filter.tags)
        filter.tags.isEmpty() -> db.imageDao().getList("${filter.name}%")
        else -> db.imageDao().getList("${filter.name}%", filter.tags)
    }

    override suspend fun addImage(image: Image) {
        db.imageDao().insert(image)
    }

    override suspend fun deleteImage(imagePath: Uri) {
        db.imageDao().deleteImage(imagePath.toString())
    }

    override val tagsDb: TagsDb = object : TagsDb {
        override fun getList(ids: Set<Int>): Flow<List<ListTag>> = when {
            ids.isEmpty() -> db.tagsDao().getList()
            else -> db.tagsDao().getList(ids.toTypedArray())
        }

        override suspend fun getTag(id: Int): Tag? = db.tagsDao().getTag(id)

        override suspend fun checkTagExists(nameSearch: String): Boolean = db.tagsDao().checkTagExists(nameSearch)

        override suspend fun upsertTag(tag: Tag) = db.tagsDao().upsertTag(tag)

        override suspend fun deleteTag(id: Int) = db.tagsDao().deleteTag(id)
    }

    companion object {
        private const val DATABASE_NAME = "photo.db"

        fun create(context: Context): PhotoDb = PhotoDbImpl(
            Room
                .databaseBuilder(context, RoomDb::class.java, DATABASE_NAME)
                .addMigrations(
                    MIGRATION_1_2,
                    MIGRATION_3_4
                )
                .build()
        )
    }
}

/**
 * Photo database implementation generated by Room
 */
@Database(
    entities = [
        Image::class,
        Tag::class
    ],
    version = 4,
    exportSchema = true,
    autoMigrations = [
        AutoMigration(from = 2, to = 3)
    ]
)
@TypeConverters(Converters::class)
internal abstract class RoomDb : RoomDatabase() {

    abstract fun imageDao(): PhotoDao

    abstract fun tagsDao(): TagsDao

}

/**
 * Migration from version 1 (Vanilla) to 2 (Room)
 */
val MIGRATION_1_2 = object : Migration(1, 2) {
    override fun migrate(db: SupportSQLiteDatabase) {
        db.execSQL("CREATE INDEX IF NOT EXISTS `index_photo_name` ON `photo` (`name`)")
        db.execSQL("CREATE INDEX IF NOT EXISTS `index_photo_created` ON `photo` (`created`)")
    }
}

/**
 * Migration from version 3 (Embedded tag) to 4 (Tags table)
 */
val MIGRATION_3_4 = object : Migration(3, 4) {
    override fun migrate(db: SupportSQLiteDatabase) {
        // Create tag table
        db.execSQL("CREATE TABLE IF NOT EXISTS `tag` (`id` INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, `name` TEXT NOT NULL, `description` TEXT NOT NULL)")
        db.execSQL("CREATE UNIQUE INDEX IF NOT EXISTS `index_tag_name` ON `tag` (`name`)")

        db.transaction {

            // Add tag ID column to photo
            db.execSQL("ALTER TABLE `photo` ADD COLUMN `tag_id` INTEGER DEFAULT NULL")

            // Copy tags from photo
            db.execSQL("""
                INSERT INTO `tag` (`name`, `description`)
                    SELECT DISTINCT 
                        `tagname`,
                        `tagdescription` 
                    FROM `photo` 
                    WHERE `tagname` IS NOT NULL
                    ORDER BY `created` ASC
                ON CONFLICT(`name`) DO UPDATE SET `description` = excluded.`description`
            """.trimIndent())

            // Update photo with tag id
            db.execSQL("""
                UPDATE `photo` SET `tag_id` = (
                    SELECT `id` FROM `tag` WHERE `tag`.`name` = `photo`.`tagname`
                )
            """.trimIndent())

            // Move tag to tag reference
            db.execSQL("ALTER TABLE `photo` RENAME TO `photo_old`")
            db.execSQL("CREATE TABLE IF NOT EXISTS `photo` (`path` TEXT NOT NULL, `name` TEXT NOT NULL, `created` TEXT NOT NULL, `tag` INTEGER, PRIMARY KEY(`path`), FOREIGN KEY(`tag`) REFERENCES `tag`(`id`) ON UPDATE CASCADE ON DELETE SET NULL )")
            db.execSQL("INSERT INTO `photo` (`path`, `name`, `created`, `tag`) SELECT `path`, `name`, `created`, `tag_id` FROM `photo_old`")
            db.execSQL("DROP TABLE `photo_old`")
            db.execSQL("CREATE INDEX IF NOT EXISTS `index_photo_name` ON `photo` (`name`)")
            db.execSQL("CREATE INDEX IF NOT EXISTS `index_photo_created` ON `photo` (`created` DESC)")
            db.execSQL("CREATE INDEX IF NOT EXISTS `index_photo_tag` ON `photo` (`tag`)")
        }
    }
}