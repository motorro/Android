# Задание Compose

Это задание основано на приложении из предыдущей работы. Мы будем развивать приложение [Cookbook](/cookbook/README.md),
постепенно мигрируя проект на новый фреймворк. Модуль уже содержит все необходимые компоненты для прошлого задания и полностью работает.
В рамках этой практики мы не только познакомимся с созданием Compose-view, но и займемся миграцией существующего приложения с классических
View и навигации на современный стек.

Приложение уже разделено на отдельные модули:

- `model` - содержит общие модели данных приложения и сервера
- `core` - базовые структуры и функции
- `domain` - бизнес-правила
- `data` - реализация обмена данными с сервером и локального хранения
- `mockdata` - тестовая реализация доменных интерфейсов
- `appcore` - базовые компоненты всех UI-модулей
- `login` - пользовательский интерфейс авторизации
- `recipelist` - пользовательский интерфейс списка рецептов
- `addrecipe` - пользовательский интерфейс нового рецепта
- `recipe` - пользовательский интерфейс рецепта
- `cookbook` - модуль приложения, собирающий все вместе.

В этот раз, мы с вами сделаем следующие шаги:

- Модуль за модулем переведем приложение на использование Compose. Это позволит нам попрактиковаться в Compose View и в миграции существующий проектов.
- Переведем приложение на обновленную библиотеку навигации, используя [Navigation Compose](https://developer.android.com/jetpack/compose/navigation).
- Попробуем традиционную архитектуру и архитектуру [StateMachine](https://github.com/motorro/CommonStateMachine)

## Готовое решение

Готовое решение для этого задания можно посмотреть в отдельной [ветке репозитория](https://github.com/motorro/Android/tree/practice/7.Compose-solution/cookbook).

## 1. Основная часть задания: переход на Compose

В этой части мы мигрируем интерфейс приложения на использование Compose. Также мы займемся рефакторингом моделей на использование
State Machine. Это упростит логику и поможет покрыть ее Unit-тестами.

### 1.1. Подготовка модулей и тема приложения

- Добавьте зависимости на плагин компоненты Compose к модулю [appcore](/cookbook/appcore/build.gradle.kts)
- Создайте тему приложения по вашему вкусу при помощи инструмента [Material Theme Builder](https://material-foundation.github.io/material-theme-builder/)
- Сохраните тему в модуль `appcore` и исправьте шаблонный код для использования в вашем проекте.

### 1.2. Переход на Compose внутри модуля **login**

Будем переходить на `Compose` модуль за модулем и будем сохранять общую структуру проекта и навигации на первом этапе.
Поэтому, в этом шаге, для примера, переведем на `Compose` внутреннюю структуру модуля `login`. Для этого, воспользуемся документацией
с официального сайта: [ComposeView in Fragments](https://developer.android.com/develop/ui/compose/migrate/interoperability-apis/compose-in-views#compose-in-fragments).

План работ:

1. Напишите Composable функцию экрана авторизации. Используйте существующую модель данных. У вас должна получиться функция примерно следующего вида:
    ```kotlin
    @Composable
    fun LoginScreen(
        state: LoginViewState,
        onLoginChanged: (String) -> Unit,
        onPasswordChanged: (String) -> Unit,
        onLoginPressed: () -> Unit,
        onComplete: () -> Unit, // Используйте для завершения навигации во фрагменте
        modifier: Modifier = Modifier
    ) { }
    ```
2. Перенесите в `Compose` все элементы из [файла верстки фрагмента](/cookbook/login/src/main/res/layout/fragment_login.xml).
3. Удалите классические виджеты из фрагмента и добавьте `ComposeView`, занимающий все пространство фрагмента.
4. Перепишите код фрагмента, чтобы он использовал `ComposeView`, как указано по ссылке в описании раздела.
5. Подключите существующую модель к новому отображению.
6. Проверьте работу приложения.

### 1.3. Рефакторинг Composable экрана и модели с использованием и жестов.

Состояние нашего экрана уже однозначно описывается структурой [LoginViewState](cookbook/login/src/main/kotlin/com/motorro/cookbook/login/data/LoginViewState.kt), 
поэтому сигнатура функции экрана получилась относительно простой. Давайте полностью перейдем на рекомендуемую MVI архитектуру и создадим единую точку входа для 
всех действий пользователя. 

1. Опишите все возможные действия с моделью при помощи закрытой структуры `LoginGesture`
2. В модели сделайте единую точку входа - функцию `process`, которая принимает `LoginGesture` и производит соответствующие действия.

В результате, у вас должна получиться функция с примерно следующего вида:

```kotlin
@Composable
fun LoginScreen(
   state: LoginViewState,
   onGesture: (LoginGesture) -> Unit,
   onComplete: () -> Unit, // Используйте для завершения навигации во фрагменте
   modifier: Modifier = Modifier
) {}
```

### 1.4. Рефакторинг модели с использованием StateMachine

К этому моменту, вся логика нашего экрана авторизации определяется внутри [LoginViewModel](cookbook/login/src/main/kotlin/com/motorro/cookbook/login/LoginViewModel.kt)
и, в целом, нам удалось построить полную UDF/MVI архитектуру в рамках модуля `login`. Однако, наша модель, на мой взгляд, содержит следующие недостатки:

1. Одна модель обслуживает три экрана, что нарушает принцип Single Responsibility и усложняет логику.
2. Модель никак не разделяет допустимые действия для разных состояний экрана. Например, изменение имени пользователя и пароля может происходить и в состоянии 
   аутентификации. В нашем случае, это не страшно, однако при усложнении логики может привести к проблемам.
3. Тестирование модели возможно только интегрально. Нам, относительно трудно протестировать отдельно состояние формы ввода данных и обращение на сервер. Опять 
   же, это может принести сложности и проблемы в поддержке модели при усложнении логики.

Я предлагаю попробовать перевести модель авторизации на более поддерживаемое и понятное решение при помощи паттерна `State Machine`.

Сценарий:

1. Подготовьте модуль `login` для использования State Machine: добавьте зависимости, создайте интерфейс фабрики и базовый класс State Machine.
2. Напишите класс `LoginFormState`, который будет отвечать за обслуживание формы. Создайте тест для него.
3. Напишите класс `TerminatedState`, который будет отвечать за завершенное состояние. Установите `LoginViewState.LoggedIn` в функции `doStart`.
4. Напишите класс `LoggingInState`, который будет запускать процесс аутентификации и переходить к состоянию `TerminatedState` в случае успешной авторизации и 
   обратно к состоянию формы в случае ошибки. Создайте тест для него.
5. Напишите реализацию фабрики состояний и соберите новую модель с использованием State Machine.

### 1.5. Общие Composable функции для экрана авторизации и ошибки.

Для перевода остальных модулей на использование Compose, нам нужно подготовить общие экраны. 

1. Создайте Composable функцию `AuthPromptView` на основе [layout_auth.xml](/cookbook/appcore/src/main/res/layout/layout_auth.xml) и поместите ее 
   в модуль `appcore`.
2. Создайте Composable функцию `ErrorView` на основе [layout_error.xml](/cookbook/appcore/src/main/res/layout/layout_error.xml) и поместите ее 
   в модуль `appcore`.
3. Опционально, создайте Composable функцию `LceView`, которая будет разбирать состояние загрузки данных. Наша задача в этом пункте - облегчить разбор состояния
   экрана, как мы делали в [RecipeFragment](/cookbook/recipe/src/main/kotlin/com/motorro/cookbook/recipe/RecipeFragment.kt)

### 1.6. Переделываем экран рецепта на Compose и StateMachine

Для практики, переделаем экран рецепта на использование Compose и State Machine. Мы можем оставить и нашу текущую модель, так как она простая, но сделаем это, 
чтобы "набить руку".
Представим логику экрана тремя основными состояниями и одним служебным - для перехода в "мир навигации":

1. Состояние `ContentState` - в этом состоянии мы подписываемся на репозиторий и просто транслируем LCE-поток в наш ui-state.
2. Состояние `DeleteConfirmationState` - при переходе в это состояние мы фиксируем внутренние данные и показваем диалог подтверждения. 
3. Состояние `DeletingState` - в этом состоянии мы вызваем репозиторий и удаляем рецепт. Мы также можем использовать данные, полученные в `ContentState`, 
   для отображения экрана.
4. Состояние `Terminated` - так же, как и в случае аутентификации, будем использовать это состояние для завершения работы фрагмента. В это состояние мы будем 
   переходить по нажатию `Back` и после удаления рецепта.

План работ:

1. Создайте набор жестов `RecipeGesture`, содержащий все необходимые жесты экрана.
2. Создайте набор состояний `RecipeViewState`, содержащий все возможные состояния экрана: `Content`, `DeleteConfirmation`, `Deleting`, `Terminated`. 
3. Создайте экран рецепта `RecipeScreen` для работы с этими состояниями. Предусмотрите обратный вызов для перехода к авторизации.
4. Пользуйтесь приложением `recipedemo` для отладки экрана.

### 1.7. Переход на Compose внутри модуля добавления рецепта

Переведем на Compose модуль добавления рецепта. Для практики также воспользуемся подходом MVI: жестами и закрытой структурой состояния экрана.
Также, для практики, переведем модель на использование State Machine. У нас три состояния логики:

1. Состояние `FormState` - в этом состоянии мы заполняем и валидируем форму.
2. Состояние `AddingRecipeState` - при переходе в это состояние мы фиксируем внутренние данные и сохраняем рецепт в репозиторий.
3. Состояние `Terminated` - так же, как и в предыдущем задании, будем использовать это состояние для завершения работы фрагмента. 

План работ:

1. Напишите структуры `AddRecipeGesture` и `AddRecipeViewState`, которые опишут состояние вашего экрана.
2. Перенесите в `Compose` все элементы из [файла верстки фрагмента](/cookbook/addrecipe/src/main/res/layout/fragment_add_recipe.xml).
3. Напишите состояния модели State Machine аналогично предыдущим заданиям.

### 1.8. Переход на Compose внутри модуля списка рецептов

Переведем на Compose и State Machine модуль списка рецепта. У нас три состояния логики:

1. Состояние `ContentState` - показываем список элементов.
2. Состояние `LoggingOutState` - выполняем процедуру выхода.
3. Состояние `Terminated` - так же, как и в предыдущем задании, будем использовать это состояние для завершения работы фрагмента. 

План работ:

1. Напишите структуры `RecipeListGesture` и `RecipeListViewState`, которые опишут состояние вашего экрана.
2. Перенесите в `Compose` все элементы из [файла верстки фрагмента](/cookbook/recipelist/src/main/res/layout/fragment_recipe_list.xml).
3. Переделайте `RecyclerView` и его элементы на [LazyColumn](https://developer.android.com/develop/ui/compose/lists)
4. Напишите состояния модели State Machine аналогично предыдущим заданиям.

### 1.9. Избавляемся от фрагментов и переходим на Navigation Compose

Теперь, все наши экраны основаны на Compose и мы можем избавиться от фрагментов и заменить навигацию на [Compose Navigation](https://developer.android.com/develop/ui/compose/navigation).

План работ:

1. Удалите зависимости на библиотеки Fragment Navigation и добавьте библиотеки [Compose Navigation](https://developer.android.com/develop/ui/compose/navigation#setup) 
   и [Hilt Navigation](https://developer.android.com/training/dependency-injection/hilt-jetpack#viewmodel-navigation).
2. Удалите фрагменты модулей
3. Заведите навигационные точки в общем модуле приложения `appcore` по аналогии с [дип-линками](/cookbook/appcore/src/main/kotlin/com/motorro/cookbook/appcore/navigation/Links.kt) 
   классической навигации. Например, маршрут навигации для списка рецептов может выглядеть так:
   ```kotlin
    /**
     * Recipe list destination
     */
    @Serializable
    data object RecipeListDestination : Destination
   ```
4. Создайте билдеры навигационных точек в модулях. Например, билдер для экрана списка рецептов может выглядеть так:
   ```kotlin
   fun NavGraphBuilder.recipeListGraph(navController: NavController) {
      composable<Destination.RecipeListDestination> {
           val model: RecipeListViewModel = hiltViewModel()

           RecipeListScreen(
               viewState = model.viewState.collectAsStateWithLifecycle().value,
               onGesture = model::process,
               onRecipe = {
                   navController.navigate(Destination.RecipeDestination(it.toString()))
               },
               onAddRecipe = {
                   navController.navigate(Destination.AddRecipeDestination)
               },
               onLogin = {
                   navController.navigate(Destination.LoginDestination)
               },
               onTerminated = { navController.popBackStack() }
           )
       }
   }
   ```
5. Переделайте код основной Activity на использование Compose-содержимого.
6. Удалите XML-граф из основного модуля и инициализируйте `NavHost`, включив дочерние модули.

## 2. Дополнительное задание: полная миграция архитектуры на использование State Machine.

Эта часть задания - не обязательная. Я сам покажу вам, как мы можем полностью перевести приложение с классической поэкранной навигацией 
на глобальное использование паттерна State Machine. Вы можете следить за шагами задания по видео-презентации, а также смотреть историю
изменения кода по коммитам в [ветке с решением](https://github.com/motorro/Android/tree/practice/7.Compose-solution/cookbook).
В конце занятия вы сможете сравнить оба подхода к созданию сложного многомодульного приложения и выбрать тот, который покажется вам более
простым и удовлетворяющим вашим требованиям и подходам.

Общий план задания:

1. Сделаем сценарий создания нового рецепта дочерним к основному при помощи [ProxyMachineState](https://github.com/motorro/CommonStateMachine?tab=readme-ov-file#adopting-feature-flows).
2. Сделаем сценарий просмотра и удаления рецепта дочерним к основному при помощи [ProxyMachineState](https://github.com/motorro/CommonStateMachine?tab=readme-ov-file#adopting-feature-flows).
3. Выделим модуль логина в proxy-state и подкулючим его динамически при помощи DI
4. Сделаем полную navigation inversion и избавимся от Jetpack Navigation component.

### 2.1. Мигрируем модуль добавления рецепта в дочерний state-flow

К этому моменту, модуль добавления рецептов уже переведен на использование паттерна State Machine, однако внешнее управление 
состоянием модуля до сих пор делается средствами Android Framework.

1. У модуля выделенная ViewModel
2. Жизненный цикл модели привязан к точке навигации
3. Для завершения работы модуля, мы используем особое состояние `Terminated`, по которому запускается побочный эффект, а фактический выход из 
   модуля делает navigation controller.
 
В этом задании, для простоты, мы сделаем модуль `addrecipe` прямой зависимостью модуля списка рецептов и будем запускать его логику
в `proxy-state` основного потока состояний.

План работ:

1. Переносим зависимость модуля `addrecipe` в модуль `recipelist` из основного приложения.
2. Удаляем модель и навигационный граф модуля `addrecipe`.
3. Создаем родительский прокси-модуль в модуле `recipelist`.
4. Запускаем дочерний модуль в рамках основного flow.

### 2.2. Мигрируем модуль просмотра и удаления рецепта в дочерний state-flow

С модулем просмотра рецепта поступаем аналогично. Удаляем модель и навигационный граф модуля `recipe` и готовим его для работы в виде 
дочернего модуля в модуле `recipelist`.
 
В этом задании, так же, мы сделаем модуль `addrecipe` прямой зависимостью модуля списка рецептов и будем запускать его логику
в `proxy-state` основного потока состояний. Вы можете использовать тот же подход, что и в предыдущем задании или любой понятный вам путь подключения
дочернего состояния при помощи `ProxyMachineState`

План работ:

1. Переносим зависимость модуля `recipe` в модуль `recipelist` из основного приложения.
2. Удаляем модель и навигационный граф модуля `addrecipe`.
3. Создаем родительский прокси-модуль в модуле `recipelist`.
4. Запускаем дочерний модуль в рамках основного flow.

### 2.3. Мигрируем модуль авторизации в дочерний state-flow

В предыдущих двух заданиях мы статически подключили дочерние модули в родительский модуль `recipelist`. Модуль `login` мы используем
в двух сценариях: при просмотре списка и при просмотре рецепта. Поэтому, для демонстрации, попробуем написать общее решение для обоих модулей
и подключить его динамически при помощи DI.

План работ:

1. Проектируем API модуля авторизации и создаем его в модуле `appcore`.
2. Реализуем универсальный proxy в модуле `login`
3. Подключиваем дочерний модуль в родительские модули `recipelist` и `recipe`.
4. Подключаем логику при помощи DI.
5. Подключаем compose-view при помощи [composition local](https://developer.android.com/develop/ui/compose/compositionlocal).
6. Запускаем дочерний модуль в рамках основного flow.

### 2.4. Отключаем Jetpack Navigation Component и переходим на State Machine в основном приложении.

К этому моменту, у нас остается только одна навигационная точка - это экран списка рецептов. Закончим миграцию на модульную State Machine,
заменив модуль навигации в основном приложении на proxy-машину.

План работ:

1. Отключаем модуль навигации в основном приложении.
2. Мигрируем модуль списка рецептов в дочерний модуль State Machine
3. Организуем корневую State Machine и основную View-Model родительского приложения.

## Заключение

В данном документе мы рассмотрели процесс миграции Android-приложения на Jetpack Compose и Navigation Compose, 
а также исследовали альтернативный подход к управлению состоянием и навигацией с использованием модульной State Machine.

В основной части задания мы:

- Постепенно перевели все экраны приложения с традиционных View на Jetpack Compose.
- Реализовали навигацию между экранами с помощью Navigation Compose.
- Рефакторили ViewModel, используя паттерн MVI (Model-View-Intent) и State Machine для более четкого разделения логики и состояний.

В дополнительной части мы углубились в архитектуру State Machine и:

- Преобразовали отдельные экраны в дочерние State Machine, управляемые из родительских модулей.
- Показали, как можно организовать динамическое подключение таких модулей с помощью [ProxyMachineState](https://github.com/motorro/CommonStateMachine?tab=readme-ov-file#adopting-feature-flows) 
  и Dependency Injection.
- Полностью отказались от Jetpack Navigation Component, реализовав навигацию исключительно средствами State Machine.

В результате мы получили два варианта архитектуры приложения: один, использующий стандартные компоненты Jetpack (Compose и Navigation Compose), и второй, 
основанный на более гибкой и кастомизируемой модульной State Machine.

Предлагаю вам внимательно изучить оба подхода, сравнить их сильные и слабые стороны в контексте данного проекта. Обратите внимание на организацию кода, 
сложность управления состоянием и навигацией, а также на возможности тестирования в каждом из вариантов. Это поможет вам сделать осознанный выбор в пользу той 
или иной архитектуры для ваших будущих проектов.

