# Задание IO

В этом задании мы будем:

- Отправлять запросы на сервер при помощи Retrofit и Ktor.
- Использовать Proto-Datastore для хранения сессии пользователя.
- Использовать Room для локального хранения данных.

Начиная с этого задания, мы будем шаг за шагом развивать приложение [Cookbook](/cookbook/README.md), модификацию приложения будем делать в исходном модуле.
Описание приложения смотрите в основном файле модуля. К началу работы над заданием, приложение работает на фальшивых данных. Все его экраны можно пройти и
посмотреть, как работает приложение в динамике.

## Готовое решение

Готовое решение для этого задания можно посмотреть в отдельной [ветке репозитория](https://github.com/motorro/Android/tree/practice/5.IO-solution/cookbook).

## Фоновые задачи

По заданию, часть операций с данными нам потребуется делать в фоновых задачах, когда UI не ждет завершения операции. Например, мы хотим, чтобы добавление и 
удаление рецептов из книги выглядело "мгновенным". К этому моменту, мы еще не знакомы с сервисами и планировщиком WorkManager, поэтому везде, где вы 
видите теребование "запустить фоновую задачу" - просто запускайте корутину в `GlobalScope`. 

## Задание 1. Авторизация на сервере (login)

Для авторизации в приложении мы будем использовать [Basic HTTP authentication](https://en.wikipedia.org/wiki/Basic_access_authentication). Для простоты, мы не 
будем хранить никаких сессионных токенов, а будем использовать открытые имя пользователя и пароль, сохраняя их в 
[активной сессии](/cookbook/cookbook/src/main/kotlin/com/motorro/cookbook/app/session/data/Session.kt).
Чтобы проверить правильность имени пользователя и пароля, запросим на сервере и сделаем частью сессии сделаем также и 
[профиль](/cookbook/data/src/main/kotlin/com/motorro/cookbook/data/Profile.kt) пользователя.
Для получить данные профиля, нужно обратиться с верным заголовком авторизации по ссылке:
[http://0.0.0.0/profile](/cookbook/server/src/main/resources/openapi/documentation.yaml#L15). Менеджер сессии все сделает за вас, в этом задании вам нужно 
только правильно реализовать работу сетевого интерфейса [UserApi](/cookbook/cookbook/src/main/kotlin/com/motorro/cookbook/app/session/UserApi.kt).

Задание:

- Добавьте нужные разрешения для использования сети в манифест.
- Вы можете использовать любую реализацию работы с HTTP, но для практики, в этом задании, я предлагаю использовать связку библиотек 
  [OkHttp](/gradle/libs.versions.toml#L138) и [Retrofit](/gradle/libs.versions.toml#141).
- Создайте экземпляр `OkHttp`
- Создайте ретрофит. Добавьте к нему ваш экземпляр `OkHttp` и добавьте конвертер JSON [kotlin-serialization](/gradle/libs.versions.toml#142)
- Создайте интерфейс службы для получения профиля, используя аннотации `Retrofit`.
- Создайте экземпляр службы при помощи экземпляра `Retrofit` и реализуйте `UserApi` с его помощью.
- Подмените текущую mock-реализацию в приложении на вашу.

## Задание 2. Хранение сессии на диске

Для того, чтобы пользователю не нужно было вводить имя пользователя и пароль каждый раз при входе в приложение, будем хранить сессию на диске. За хранение 
сессии для `SessionManager` отвечает отдельный интерфейс [SessionStorage](/cookbook/cookbook/src/main/kotlin/com/motorro/cookbook/app/session/SessionStorage.kt), 
содержащий поток текущего состояния сессии и метод для ее изменения. Мы реализуем этот интерфейс при помощи [Proto Datastore](https://developer.android.com/codelabs/android-proto-datastore#6) 
и JSON - сериализации.

- Добавьте [зависимость на DataStore](/gradle/libs.versions.toml#L97) в сборочный сценарий модуля приложения.
- Напишите `Serializer<Session>`, используя сериализацию в JSON при помощи Kotlin Serializable.
- Создайте singleton-свойство для хранилища сессии.
- Реализуйте `SessionStorage` с использованием этого свойства.

## Задание 3. Реализация обмена рецептами с сервером

На этом этапе займемся реализацей сетевого взаимодействия приложения и нашего сервера.
Нам нужно реализовать все методы, касающиеся обмена рецептами:

- получение списка
- получение рецепта по идентификатору
- добавление рецепта
- загрузка картинки к рецепту
- удаление рецепта

Полное описание API работы с сервером смотрите в файле документации OpenAPI или, при запущенном сервере, 
по [локальной ссылке](http://0.0.0.0/openapi).

Вы можете воспользоваться любым набором библиотек для реализации API. Подробности реализации с помощью библиотеки
[Ktor Client](https://ktor.io/docs/client-create-new-application.html) смотрите в нашем видеоуроке.

- Добавьте необходимые библиотеки (по выбору)
- Все методы сетевого API требуют авторизации. Добавляейте заголовок [Basic Authentication](https://en.wikipedia.org/wiki/Basic_access_authentication), используя
  имя пользователя и пароль из текущей активной сессии.
- Создайте реализацию [RecipeRepository](/cookbook/cookbook/src/main/kotlin/com/motorro/cookbook/app/repository/RecipeRepository.kt) с помощью вашего сетевого
  интерфейса.

Реактивным обновлением списков и рецептов в этом задании можно пренебречь. Основная задача - полная реализация сетевого интерфейса: запрос списков и рецептов, 
создание нового рецепта, загрузка картинки на сервер. Дополнительную помощь по составлению запросов к серверу можно посмотреть в 
[файле тестов](/cookbook/server/src/test/kotlin/com/motorro/cookbook/server/ApplicationKtTest.kt) сервера.

## Задание 4. Репозиторий рецептов

В этом задании мы создадим полноценный репозиторий рецептов с двумя источниками: сервером и локальной базой данных Room. База данных будет выступать 
"источником правды" и синхронизировать рецепты с сервером. Для упрощения синхронизации, мы сделали следующие шаги:

- Идентификатор рецепта - это [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) - уникальный идентификатор. Когда мы создаем рецепт 
  в приложении и посылаем его на сервер, мы считаем, что рецепт всегда будет уникальным.
- Когда мы стираем рецепт, он не удаляется из базы данных, а помечается флагом `deleted`. Таким образом, у нас нет нужды в программировании синхронизации 
  удалений элементов списка.

Требования:

- Если у нас есть активная сессия, и мы уже один раз загрузили список рецептов, пользователь может смотреть рецепты даже при неработающем сервере
- Добавление и удаление рецептов в локальную базу рецептов, с точки зрения пользователя, происходит "мгновенно". Поэтому методы репозитория `addRecipe` и 
  `deleteRecipe` - синхронные. Операции по записи базы данных и сетевой запрос будем выполнять в фоновой задаче.
- Когда пользователь открывает приложение, список рецептов или рецепт синхронизируется с сервером.
- У пользователя есть возможность вручную обновить список рецептов из основного экрана.
- Синхронизацию рецептов нужно проводить в фоновой задаче (методы `synchronizeList` и `synchronizeRecipe` - синхронные).
- Нужно отображать состояние синхронизации и ошибки в интерфейсе. Поэтому мы используем потоки [LCEState](/core/src/main/kotlin/com/motorro/core/lce/LceState.kt)
  в качестве элемента данных при загрузке списка и рецепта в сыойстве `recipes` и методе `getRecipe` нашего репозиторя.

Подробности реализации смотрите в нашем видеоуроке, а вот примерные шаги для выполнения задания:

- Добавьте в проект зависимости Room: плагин обработки аннотаций [KSP](/gradle/libs.versions.toml#L158), процессор и runtime-библиотеку [Room](/gradle/libs.versions.toml#L101).
- Создайте [конфигурацию](https://developer.android.com/training/data-storage/room#setup) KSP и Room в build-script приложения.
- Создайте entity для элемента списка и полных данных рецепта.
- Реализуйте методы репозитория для сочетания загрузки данных из локальной базы и сервера таким образом, чтобы изменение в базе данных вызывало реактивное
  обновление списка рецептов и данных рецепта через методы `recipes` и `getRecipe` репозитория.
- Выполните добавление и удаление рецептов рецептов в базу данных с последующим вызовом синхронизации в фоновой задаче.




