# Задание Background

Это задание основано на приложении из предыдущей работы. Мы будем развивать приложение [Cookbook](/cookbook/README.md),
и заменим операции синхронизации списка, создания и удаления рецептов на использование [WorkManager](https://developer.android.com/develop/background-work/background-tasks/persistent/getting-started). 
Модуль основан на полностью реализованом приложении из наших прошлых заданий.

В этот раз, мы с вами сделаем следующие шаги:

- Добавим зависимости на `WorkManager` и инициализируем библиотеку для совместного использования с [Hilt](https://developer.android.com/training/dependency-injection/hilt-jetpack#workmanager).
- Напишем задачу для периодического обновления списка рецептов.
- Напишем задачу для удаления рецепта с сервера.
- Напишем задачу для добавления рецепта на сервер.

## Готовое решение

Готовое решение для этого задания можно посмотреть в отдельной [ветке репозитория](tree/practice/8.Background-solution/cookbook).

## 1. Инициализация WorkManager

Для инициализации `WorkManager` и его совместной работы с `Hilt` воспользуйтесь документацией к библиотекам:

- [Совместная работа Hilt и WorkManager](https://developer.android.com/training/dependency-injection/hilt-jetpack#workmanager)]
- [Специальная конфигурация WorkManager](https://developer.android.com/develop/background-work/background-tasks/persistent/configuration/custom-configuration)
- [App Startup](https://developer.android.com/topic/libraries/app-startup)

Пример такой инициализации можно найти в [материалах к нашей прошлой лекции](/tree/webinars/35.Background/background/src/main)

Последовательность шагов:

1. Добавляем зависимости на библиотеки `WorkManager` и плагин `dagger.hilt.android` в модуль `data`.
2. Добавляем зависимости на библиотеки `WorkManager` и плагин `dagger.hilt.android` в модуль `cookbook`. Дополнительно добавляем зависимость на библиотеку 
   `androidx.startup`.
3. Создаем класс инициализации, реализующий `Initializer<WorkManager>` в модуле `cookbook`. Для примера смотрите документацию выше и готовый пример в нашей 
   [лекции по фоновой](/blob/webinars/35.Background/background/src/main/kotlin/com/motorro/background/init/WorkManagerInitializer.kt) работе.
4. Регистрируем инициализатор в манифесте по инструкции или по [примеру](/blob/webinars/35.Background/background/src/main/AndroidManifest.xml).

### 2. Переделываем загрузку списка рецептов с использованием однократной задачи WorkManager

На сегодня, use-case загрузки списка рецептов явно использует основной `CoroutineScope` нашего приложения для синхронизации списка рецептов.
В этом подходе есть недостатки:

- Синхронизация может неожиданно завершиться, если процесс приложения перешел в фон и система освобождает ресурсы.
- Не обрабатываются ошибки синхронизации.

Изменим наш модуль данных таким образом, чтобы операция синхронизации списка делалась при помощи `WorkManager`.

Последовательность шагов:

1. Создаем новый `Worker`, который будет вызывать `cookbookApi.getRecipeList()` и записывать данные в базу данных с помощью `cookbookDao.insertList(...)`.
2. Модифицируем функцию `synchronize()` в [RecipeListUsecase](/cookbook/data/src/main/kotlin/com/motorro/cookbook/data/recipes/usecase/RecipeListUsecase.kt). 
   Удаляем код, непосредственно вызывающий методы получения рецептов и записи их в базу данных. Вместо этого, отправляем в `WorkManager` запрос на одиночный 
   запуск нашего `Worker`.
3. Для свойства `recipes` нам необходимо реализовать поток `LCE` состояний. Для этого получим поток данных о состоянии заданий `WorkManager` и нашего `Worker`.
   Воспользуйтесь одним из методов получения состояния задач. Например `getWorkInfosByTagFlow`. Преобразуйте поток данных о состоянии таким образом, чтобы:
   
   - `WorkInfo.State.RUNNING` приводил к состоянию `LceState.Loading` на выходе
   - `WorkInfo.State.FAILED` приводил к состоянию `LceState.Error` на выходе
   - все остальные входные состояния приводили к состоянию `LceState.Content` на выходе

### 3. Подключаем задачу периодического фонового обновления списка

В прошлом задании мы переделали загрузку списка рецептов с сервера с использованием одиночной задачи `WorkManager`. В этом задании усовершенствуем наше
приложение и будем автоматически обновлять список в фоновой задаче. Для этого, предлагаю следующий сценарий:

- ставить периодическую задачу в `WorkManager`, когда пользователь авторизовался.
- снимать периодическую задачу, когда пользователь вышел из системы.

Последовательность шагов:

1. Выбираем способ отслеживать факты входа и выхода пользователя из системы. Это может быть какой-то монитор сессии или плагин к нашему 
   [SessionManager](/cookbook/domain/src/main/kotlin/com/motorro/cookbook/domain/session/SessionManagerImpl.kt).
2. Когда пользователь вошел в систему, ставим уникальную периодическую задачу, используя `Worker` синхронизации из предыдущего задания.
3. Когда пользователь выходит из системы, снимаем задачу из планировщика при помощи одного из методов `WorkManager`, например `cancelAllWorkByTag()`.

### 4. Фоновое удаление рецепта с сервера

В этом задании мы переделаем наш [use-case удаления рецепта](/cookbook/data/src/main/kotlin/com/motorro/cookbook/data/recipes/usecase/DeleteRecipeUsecase.kt).
Воспользуемся `WorkManager`, чтобы сделать фоновую работу более надежной.

Последовательность шагов:

1. Создаем новый `Worker` и переносим в него код из use-case для обращения к серверу - вызов метода `cookbookApi.deleteRecipe(recipeId)`.
2. Для выполнения задания нам необходимо передать в `Worker` идентификатор рецепта. Воспользуйтесь методом `setInputData` билдера задания `WorkManager` для 
   передачи идентификатора из use-case.
3. Читайте это значение из входных данных в методе `doWork()`.
4. Замените явный вызов API в use-case удаления рецепта на постановку уникальной задачи в `WorkManager`.

### 5. Создание нового рецепта с помощью составной задачи

Создание нового рецепта на сервере состоит из одного или двух шагов:

1. Создание основы рецепта при помощи вызова метода: `addRecipe(recipe: Recipe): Result<Recipe>`
2. Если рецепт содержит картинку, дополнительного шага по загрузке картинки к рецепту: `uploadRecipeImage(recipeId: Uuid, imageUri: Uri): Result<ImageUpload>`

Сейчас оба этих метода явно вызываются в [AddRecipeUsecase](/cookbook/data/src/main/kotlin/com/motorro/cookbook/data/recipes/usecase/AddRecipeUsecase.kt).
Давайте переделаем этот use-case на использование составной задачи `WorkManager`.

Последовательность шагов:

1. Создаем `Worker` для загрузки основной части рецепта.
2. Создаем `Worker` для загрузки картинки.
3. Изменяем use-case создания рецепта таким образом, чтобы вместо явного вызова API в `WorkManager` создавалась составная задача для обоих пунктов выше.
4. Дополнительно, запускаем синхронизацию списка при помощи `Worker` из второго задания при успешном завершении основной операции.

### Вывод

Эта практическая работа посвящена усовершенствованию приложения "Кулинарная книга" путем переноса фоновых операций (синхронизация списка, создания и удаления 
рецептов) с использованием `WorkManager`.

Наши основные достижения:

*   **Инициализация WorkManager:** Интеграция `WorkManager` с Hilt для внедрения зависимостей и его настройка с использованием `App Startup`.
*   **Синхронизация списка рецептов:** Рефакторинг загрузки списка рецептов для использования одноразовой задачи `WorkManager`, что повышает надежность и 
*   улучшает обработку ошибок. В этом задании мы также научились получать состояние выполнения задач `WorkManager`.
*   **Периодические обновления списка:** Реализация периодических фоновых обновлений списка рецептов с помощью `WorkManager`, запускаемых при входе пользователя 
*   в систему и отменяемых при выходе.
*   **Фоновое удаление рецептов:** Перенос удаления рецептов на надежную задачу `WorkManager`, передача идентификаторов рецептов в качестве входных данных.
*   **Составная задача для создания рецептов:** Реализация составной задачи `WorkManager` для создания новых рецептов, которая может включать два шага: 
    создание базового рецепта и, при необходимости, загрузку изображения. Успешное создание рецепта также запускает задачу синхронизации списка.

В целом, практическая работа значительно улучшает фоновую обработку приложения за счет использования `WorkManager` для более надежных, стабильных 
и отказоустойчивых операций. Теперь наше приложение закончено и готово к выпуску.
